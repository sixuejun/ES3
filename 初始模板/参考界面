<script>
var MessageState;
(function (MessageState) {
    MessageState[MessageState["none"] = 0] = "none";
    MessageState[MessageState["auto"] = 1] = "auto";
    MessageState[MessageState["skip"] = 2] = "skip";
})(MessageState || (MessageState = {}));
class TextInfo {
    character;
    clothing;
    mood;
    scene;
    text;
}
class MessageInfo {
    mesid;
    _textIndex;
    get textIndex() {
        return this._textIndex;
    }
    set textIndex(value) {
        this._textIndex = value;
        this.charIndex = 0;
    }
    charIndex;
    state;
    timeoutID;
    nameElement;
    textElement;
    sceneElement;
    indicatorElement;
    nextElement;
    autoTeggleElement;
    skipTeggleElement;
    tempElement;
    portraitElements;
    texts;
    constructor() {
        this.textIndex = 0;
        this.charIndex = 0;
        this.state = MessageState.none;
    }
    setElement(mes_text) {
        this.nameElement = $(".custom-name", mes_text)[0];
        this.textElement = $(".custom-text", mes_text)[0];
        this.portraitElements = $(".custom-portrait", mes_text);
        this.sceneElement = $(".custom-scene", mes_text)[0];
        this.indicatorElement = $(".custom-text-indicator", mes_text)[0];
        this.indicatorElement.textContent = 1 + "/" + this.texts.length;
        this.nextElement = $(".custom-text-next-img", mes_text)[0];
        this.autoTeggleElement = $(".custom-auto-toggle", mes_text)[0];
        this.skipTeggleElement = $(".custom-skip-toggle", mes_text)[0];
    }
}
class StreamInfo {
    mesid;
    character;
    scene;
    text;
    textLength;
    textCount;
    characters;
    textElement;
    sceneElement;
    portraitsElement;
    indicatorElement;
    constructor() {
        this.textCount = 0;
        this.characters = new Set;
    }
}
function jumpAnimate(element, count, speed = 10, minPosition = -30, maxPosition = 0) {
    let position = 0;
    let direction = -1;
    let completedCount = 0;
    const animate = () => {
        if (completedCount < count) {
            position += direction * 5;
            if (position > maxPosition) {
                direction *= -1;
                completedCount++;
            }
            else if (position < minPosition) {
                direction *= -1;
            }
            element.style.top = position + "px";
            setTimeout(requestAnimationFrame, speed, animate);
        }
        else {
            element.style.top = "0px";
        }
    };
    requestAnimationFrame(animate);
}
;
function showText(msgInfo, textInfo, charTimeout = charAutoInterval) {
    msgInfo.textElement.textContent = "";
    msgInfo.nameElement.textContent = textInfo.character;
    msgInfo.nextElement.style.opacity = "0";
    msgInfo.indicatorElement.textContent = (msgInfo.textIndex + 1) + "/" + msgInfo.texts.length;
    let portrait;
    if (portraitImageMap.has(textInfo.character)) {
        for (let i = 0; i < msgInfo.portraitElements.length; i++) {
            portrait = msgInfo.portraitElements[i];
            if (portrait.getAttribute("alt") === textInfo.character) {
                portrait.style.opacity = "1.0";
                portrait.setAttribute("src", catboxFormat.format(portraitImageMap.get(textInfo.character)?.get(textInfo.clothing)?.getX(textInfo.mood)));
            }
            else
                portrait.style.opacity = "0.6";
        }
    }
    else {
        msgInfo.portraitElements.css("opacity", "1.0");
    }
    msgInfo.sceneElement.setAttribute("src", catboxFormat.format(sceneImageMap.getX(textInfo.scene)));
    if (portrait) {
        jumpAnimate(portrait, 2);
    }
    if (charTimeout === 0) {
        msgInfo.textElement.innerHTML = textInfo.text;
        msgInfo.nextElement.style.opacity = "1.0";
    }
    else {
        showChar(textInfo.text, charTimeout);
    }
    function showChar(text, timeout) {
        if (msgInfo.charIndex < text.length) {
            let hasWord = false;
            filterWordMap.forEach((words, length) => {
                var word = text.substring(msgInfo.charIndex, msgInfo.charIndex + length);
                if (words.has(word)) {
                    msgInfo.textElement.innerHTML += word;
                    let elementName = word.match(elementNameRagex)[1];
                    if (msgInfo.tempElement?.localName === elementName) {
                        msgInfo.tempElement = undefined;
                    }
                    else {
                        msgInfo.tempElement = $(`${elementName}`, msgInfo.textElement)[0];
                        hasWord = true;
                    }
                    msgInfo.charIndex += length;
                }
            });
            if (msgInfo.tempElement === undefined) {
                msgInfo.textElement.innerHTML += text.charAt(msgInfo.charIndex);
                msgInfo.charIndex++;
            }
            else if (hasWord === false) {
                msgInfo.tempElement.innerHTML += text.charAt(msgInfo.charIndex);
                msgInfo.charIndex++;
            }
            msgInfo.timeoutID = setTimeout(showChar, timeout, text, timeout);
        }
        else {
            clearTimeout(msgInfo.timeoutID);
            msgInfo.timeoutID = undefined;
            msgInfo.tempElement = undefined;
            msgInfo.nextElement.style.opacity = "1.0";
            msgInfo.timeoutID = tryNextText(msgInfo);
        }
    }
}
function tryNextText(msgInfo, timeout = undefined) {
    if (msgInfo.timeoutID !== undefined)
        return;
    if (msgInfo.textIndex < msgInfo.texts.length - 1 && msgInfo.state !== MessageState.none) {
        if (msgInfo.state === MessageState.auto) {
            timeout ??= messageAutoInterval;
            return setTimeout(show, timeout);
        }
        else if (msgInfo.state === MessageState.skip) {
            timeout ??= messageSkipInterval;
            return setTimeout(show, timeout);
        }
    }
    else {
        msgInfo.state = MessageState.none;
        msgInfo.autoTeggleElement.checked = false;
        msgInfo.skipTeggleElement.checked = false;
    }
    function show() {
        msgInfo.textIndex++;
        showText(msgInfo, msgInfo.texts[msgInfo.textIndex], msgInfo.state === MessageState.auto ? charAutoInterval : charSkipInterval);
    }
}
function nextText(msgInfo, increase) {
    clearTimeout(msgInfo.timeoutID);
    if (msgInfo.timeoutID !== undefined || msgInfo.state !== MessageState.none) {
        msgInfo.state = MessageState.none;
        msgInfo.autoTeggleElement.checked = false;
        msgInfo.skipTeggleElement.checked = false;
        msgInfo.tempElement = undefined;
        msgInfo.timeoutID = undefined;
        msgInfo.nextElement.style.opacity = "1.0";
        msgInfo.textElement.innerHTML = msgInfo.texts[msgInfo.textIndex].text;
        return;
    }
    msgInfo.textIndex += increase;
    if (msgInfo.textIndex > msgInfo.texts.length - 1) {
        msgInfo.textIndex = 0;
        for (let i = 0; i < msgInfo.portraitElements.length; i++) {
            let element = msgInfo.portraitElements[i];
            let character = element.getAttribute("alt");
            let textInfo = msgInfo.texts.find((info) => info.character === character);
            element.setAttribute("src", catboxFormat.format(portraitImageMap.get(textInfo.character)?.get(textInfo.clothing)?.getX(textInfo.mood)));
        }
    }
    else if (msgInfo.textIndex < 0) {
        msgInfo.textIndex = msgInfo.texts.length - 1;
        for (let i = 0; i < msgInfo.portraitElements.length; i++) {
            let element = msgInfo.portraitElements[i];
            let character = element.getAttribute("alt");
            let textInfo = msgInfo.texts.findLast((info) => info.character === character);
            element.setAttribute("src", catboxFormat.format(portraitImageMap.get(textInfo.character)?.get(textInfo.clothing)?.getX(textInfo.mood)));
        }
    }
    showText(msgInfo, msgInfo.texts[msgInfo.textIndex]);
}
function messageParser(message) {
    // [[character||{{name}}||{{clothing}}||{{scene}}||{{mood}}||{{text}}]]
    // [[narration||{{scene}}||{{message}}]]
    let infos = new Array();
    let matchs = [...message.matchAll(messageRagex)];
    for (let i = 0; i < matchs.length; i++) {
        let info = new TextInfo();
        let text = matchs[i][0];
        let match = text.match(dialogueRagex);
        if (match && match.length > 1) {
            info.character = match[1];
            info.scene = match[2];
            info.clothing = match[3];
            info.mood = match[4];
            info.text = match[5];
        }
        else {
            match = text.match(narrationRagex);
            info.character = "";
            info.scene = match[1];
            info.text = match[2];
        }
        infos.push(info);
    }
    return infos;
}
function registeredEvent(msgInfo, mes_text) {
    let element = $(".custom-text-next", mes_text);
    element.on("click", _ => nextText(msgInfo, 1));
    element = $(".custom-text-previous", mes_text);
    element.on("click", _ => nextText(msgInfo, -1));
    element = $(".custom-auto-button", mes_text);
    element.on("click", ev => {
        ev.target.previousElementSibling.click();
        if (msgInfo.state !== MessageState.auto) {
            msgInfo.state = MessageState.auto;
            msgInfo.skipTeggleElement.checked = false;
            msgInfo.timeoutID = tryNextText(msgInfo, 0);
        }
        else {
            msgInfo.state = MessageState.none;
            clearTimeout(msgInfo.timeoutID);
            msgInfo.timeoutID = undefined;
        }
    });
    element = $(".custom-skip-button", mes_text);
    element.on("click", ev => {
        ev.target.previousElementSibling.click();
        if (msgInfo.state !== MessageState.skip) {
            msgInfo.state = MessageState.skip;
            msgInfo.autoTeggleElement.checked = false;
            msgInfo.timeoutID = tryNextText(msgInfo, 0);
        }
        else {
            msgInfo.state = MessageState.none;
            clearTimeout(msgInfo.timeoutID);
            msgInfo.timeoutID = undefined;
        }
    });
}
async function messageAction(mesid, mes_text) {
    streamStart = false;
    streamInfo = undefined;
    if (mes_text === undefined) {
        // 如果是不是AI消息则跳过
        let mes = $(`.mes[mesid='${mesid}'][is_user='false'][is_system='false']`, window.parent.document);
        if (mes.length === 0)
            return;
        mes_text = $(".mes_text", mes);
    }
    if (!Number.isInteger(mesid))
        mesid = Number.parseInt(mesid.toString());
    console.log(`开始消息解析, 消息ID ${mesid}`);
    let fromEvent = mes_text === undefined;
    let msgInfo = new MessageInfo();
    msgInfo.mesid = mesid;
    let messages = await getChatMessages(mesid);
    let message = messages[0].message;
    message = renderText(message);
    // message = await formatAsDisplayedMessage(message);
    msgInfo.texts = messageParser(message);
    let characterNames = new Set();
    let portraits = "";
    for (let i = 0; i < msgInfo.texts.length; i++) {
        let textInfo = msgInfo.texts[i];
        if (portraitImageMap.has(textInfo.character) && !characterNames.has(textInfo.character)) {
            characterNames.add(textInfo.character);
            portraits += portraitFormat.format(portraitImageMap.get(textInfo.character)?.get(textInfo.clothing)?.getX(textInfo.mood), textInfo.character);
        }
    }
    message = `<style>${style}</style>
    <body>
    ${mainHTMLFormat.format("", "", "", portraits)}
    </body>`;
    mes_text[0].innerHTML = message;
    if (mes_text.length > 1) {
        mes_text[0].style.display = "";
        mes_text[1].style.display = "none";
        mes_text[1].textContent = "";
    }
    msgInfo.setElement(mes_text[0]);
    registeredEvent(msgInfo, mes_text[0]);
    messageMap.set(mesid, msgInfo);
    console.log(`完成消息解析, 消息ID ${mesid}`);
    showText(msgInfo, msgInfo.texts[0], fromEvent ? charAutoInterval : 0);
}
async function loadConfig() {
    const regexes = await getTavernRegexes({ scope: 'character', enable_state: 'enabled' });
    for (let i = 0; i < regexes.length; i++) {
        let regex = regexes[i];
        switch (regex.script_name) {
            case "黑暗模式":
                const darkMode = true;
                break;
            case "自动模式字间隔(ms)":
                charAutoInterval = tryParseInt(regex.replace_string, charAutoInterval);
                break;
            case "自动模式消息间隔(ms)":
                messageAutoInterval = tryParseInt(regex.replace_string, messageAutoInterval);
                break;
            case "快进模式字间隔(ms)":
                charSkipInterval = tryParseInt(regex.replace_string, charSkipInterval);
                break;
            case "快进模式消息间隔(ms)":
                messageSkipInterval = tryParseInt(regex.replace_string, messageSkipInterval);
                break;
        }
    }
}
let streamStart = false;
let streamParsing = false;
async function streamParser(fulltext) {
    if (streamStart === false) {
        streamStart = true;
        streamParsing = false;
        let last_mesid = Number.parseInt(await triggerSlashWithResult('/pass {{lastMessageId}}'));
        let mes_text = retrieveDisplayedMessage(last_mesid);
        streamInfo = new StreamInfo();
        streamInfo.mesid = last_mesid;
        streamInfo.textLength = fulltext.length;
        streamInfo.text = fulltext;
        streamInfo.textCount = 0;
        let temp_mes_text;
        if (mes_text.length > 1)
            temp_mes_text = mes_text[1];
        else
            temp_mes_text = mes_text.clone()[0];
        mes_text.css("display", "none");
        mes_text.after(temp_mes_text);
        let message = `<style>${style}</style>
        <body>
        ${mainHTMLFormat.format("", "", "", "")}
        </body>`;
        temp_mes_text.innerHTML = message;
        streamInfo.portraitsElement = $(".custom-portraits", temp_mes_text)[0];
        streamInfo.indicatorElement = $(".custom-text-indicator", temp_mes_text)[0];
        streamInfo.textElement = $(".custom-text", temp_mes_text)[0];
        streamInfo.sceneElement = $(".custom-scene", temp_mes_text)[0];
        streamParsing = false;
    }
    else if (streamParsing === false && streamInfo !== undefined) {
        streamParsing = true;
        let incremental_text = fulltext.slice(streamInfo.textLength);
        streamInfo.text += incremental_text;
        streamInfo.textLength += incremental_text.length;
        let messageMatch = streamInfo.text.match(messageRagex);
        if (messageMatch === null) {
            streamParsing = false;
            return;
        }
        let dialogueMatch = messageMatch[0].match(dialogueRagex);
        if (dialogueMatch) {
            streamInfo.text = streamInfo.text.replace(dialogueMatch[0], "");
            streamInfo.textCount++;
            let character = dialogueMatch[1];
            let scene = dialogueMatch[2];
            let clothing = dialogueMatch[3];
            let mood = dialogueMatch[4];
            let text = dialogueMatch[5];
            if (!streamInfo.characters.has(character) && portraitImageMap.has(character)) {
                streamInfo.characters.add(character);
                streamInfo.portraitsElement.innerHTML += portraitFormat.format(portraitImageMap.get(character)?.get(clothing)?.getX(mood), character);
            }
            if (streamInfo.textElement.textContent?.length === 0) {
                streamInfo.sceneElement.setAttribute("src", catboxFormat.format(sceneImageMap.getX(scene)));
                text = renderText(text);
                streamInfo.textElement.innerHTML = text;
            }
        }
        else {
            let narrationMatch = messageMatch[0].match(narrationRagex);
            if (narrationMatch) {
                streamInfo.text = streamInfo.text.replace(narrationMatch[0], "");
                streamInfo.textCount++;
                let scene = narrationMatch[1];
                let text = narrationMatch[2];
                if (streamInfo.textElement.textContent?.length === 0) {
                    streamInfo.sceneElement.setAttribute("src", catboxFormat.format(sceneImageMap.getX(scene)));
                    text = renderText(text);
                    streamInfo.textElement.innerHTML = text;
                }
            }
        }
        streamInfo.indicatorElement.textContent = "1/" + streamInfo.textCount;
        streamParsing = false;
    }
}
async function initialize() {
    let nodes = $("#chat", window.parent.document).children(".mes[is_user='false'][is_system='false']");
    for (let i = nodes.length - 1; i >= 0; i--) {
        let node = nodes[i];
        let mesid = Number.parseInt(node.getAttribute("mesid"));
        await messageAction(mesid, $(".mes_text", node));
    }
}
//#region Extension
function renderText(string) {
    string = string.replace(/\*{1}(.+?)\*{1}/g, "<em>$1</em>");
    return string.replace(/\"{1}(.+?)\"{1}/g, "$1");
}
function tryParseInt(string, defaultNumber) {
    let result = Number.parseInt(string);
    return Number.isNaN(result) ? defaultNumber : result;
}
function setStringFormat() {
    if (String.prototype.format !== undefined)
        return;
    String.prototype.format = function (...args) {
        return this.replace(/{{1}([0-9]+?)}{1}/g, function (match, number) {
            return typeof args[number] != "undefined" ? args[number] : match;
        });
    };
}
function setRandomElement() {
    if (Array.prototype.randomElement !== undefined)
        return;
    Array.prototype.randomElement = function () {
        let randomIndex = Math.floor(Math.random() * this.length);
        return this[randomIndex];
    };
}
function setMapGetX() {
    if (Map.prototype.getX !== undefined)
        return;
    Map.prototype.getX = function (key) {
        let value = this.get(key);
        if (Array.isArray(value))
            return value.randomElement();
        else
            return value;
    };
}
function setExtensions() {
    setStringFormat();
    setRandomElement();
    setMapGetX();
}
setExtensions();
//#endregion
console.log("全局脚本启动");
loadConfig();
initialize();


eventOn(tavern_events.MESSAGE_UPDATED, messageAction);
eventOn(tavern_events.MESSAGE_RECEIVED, messageAction);
eventOn(tavern_events.MESSAGE_SWIPED, messageAction);
eventOn(tavern_events.MESSAGE_DELETED, initialize);
eventOn(tavern_events.STREAM_TOKEN_RECEIVED, streamParser);
var charAutoInterval = 30;
var messageAutoInterval = 1000;
var charSkipInterval = 5;
var messageSkipInterval = 500;
var streamInfo;
const dialogueRagex = /\[{2}character\|{2}(.+?)\|{2}(.+?)\|{2}(.+?)\|{2}(.+?)\|{2}(.+?)\]{2}/;
const narrationRagex = /\[{2}narration\|{2}(.+?)\|{2}(.+?)\]{2}/;
const messageRagex = /\[{2}.*\]{2}/g;
const elementNameRagex = /<{1}\/*([^ >]+)[^>]*?>{1}/;
const catboxFormat = "https://files.catbox.moe/{0}.png";
const portraitFormat = `<img class="custom-portrait" src="https://files.catbox.moe/{0}.png" alt="{1}">`;
const messageMap = new Map();
const sceneImageMap = new Map([
    ["办公室-白天", "ugp0te"],
    ["办公室-夜晚", "ngcw7f"],
    ["港区-白天", ["m5ec7e", "82kb3j", "fcs2lr", "nmze4i"]],
    ["港区-夜晚", "ecg99t"],
    ["泳池", "po2maq"]
]);
const portraitImageMap = new Map([
    ["阿尔萨斯", new Map([["常服", new Map([
                    ["平静", "1khn70"],
                    ["疑惑", ["5nfkod", "96ah82"]],
                    ["开心", ["clcwpr", "loifrv", "cew2uc"]],
                    ["不开心", "q37vtn"],
                    ["惊讶", "idvx7i"],
                    ["脸红", "o0jdwq"],
                    ["害羞", ["pyjfi7", "k5a9tc"]],
                    ["脸红惊讶", ["o0jdwq", "pl5ng8"]]
                ])],
            ["泳装", new Map([
                    ["平静", ["yeer6b", "0ry8xm", "ttsckh"]],
                    ["疑惑", ["nkot8h"]],
                    ["开心", ["05d98g", "cwwntd"]],
                    ["不开心", ["6ttg4w", "a8wqcp", "8e0wlb"]],
                    ["惊讶", ["xqt4jn"]],
                    ["脸红", ["zyo11o", "ulmkc8"]],
                    ["害羞", ["ckz70f", "4o9mdb", "qmmzow"]],
                    ["脸红惊讶", ["agrqtl"]]
                ])]])]
]);
const filterWordMap = new Map([
    [4, new Set(["<em>"])],
    [5, new Set(["</em>"])],
]);
const style = `
        .custom-container {
            position: relative;
            width: 100%;
            height: 100vh;
            max-height: 400px;
            background-size: cover;
            background-position: center;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .custom-container img {
            width: auto;
        }

        .custom-portraits {
            display: flex;
            justify-content: space-around;
            align-items: center;
            width: 100%;
            height: 100%;
        }

        .custom-portrait {
            position: relative;
            object-fit: cover;
            z-index: 2;
            margin: 5px;
            max-width: 150px;
            height: 100%;
            max-height: 80% !important;
            min-width: 10%;
            min-height: 20%;
            transition: transform 0.3s ease;
        }

        .custom-portrait:hover {
            transform: scale(1.2);
        }

        .custom-scene {
            position: absolute;
            z-index: 1;
            min-height: 50%;
            height: 100%;
            min-width: 100%;
            object-fit: cover;
        }

        .custom-dialogue-box {
            z-index: 10;
            position: absolute;
            bottom: 0;
            width: 100%;
            background: linear-gradient(to top, #4a5873cc 70%, #ffffff00);
            color: white;
            padding: 30px 50px 0px 50px;
            box-sizing: border-box;
            min-height: 30%;
        }

        .custom-dialogue-box .custom-name {
            color: #00bfff;
            font-weight: bold;
            order: 2;
            pointer-events: none;
        }

        .custom-dialogue-box .custom-divider {
            height: 1px;
            background: #ffffff22;
            margin: 5px 0;
            pointer-events: none;
        }

        .custom-dialogue-box .custom-text {
            margin-top: 5px;
            white-space: pre-wrap;
            pointer-events: none;
        }

        .custom-dialogue-box .custom-info {
            display: flex;
            pointer-events: none;
        }

        .custom-name:empty+.custom-print {
            opacity: 0;
        }

        .custom-dialogue-box .custom-print {
            margin-top: 4px;
            margin-right: 8px;
            height: 14px;
            pointer-events: none;
        }

        .custom-dialogue-box .custom-text-next-img {
            position: absolute;
            right: 15px;
            bottom: 5px;
            height: 14px;
            animation: text-next-jump 1s infinite;
        }

        @keyframes text-next-jump {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-10px);
            }
        }

        .custom-dialogue-box .custom-text-action {
            display: flex;
            top: 0px;
            left: 0px;
            position: absolute;
            height: 100%;
            width: 100%;
            padding: 0px;
            margin: 0px;
            z-index: 15;
        }

        .custom-text-action div {
            height: 100%;
            width: 50%;
            position: relative;
        }

        .custom-dialogue-box .custom-text-indicator {
            opacity: 0.6;
            position: absolute;
            right: 5px;
            bottom: 30px;
        }

        .custom-topbar {
            z-index: 10;
            padding: 10px;
            width: 100%;
            background: linear-gradient(to bottom, #4a5873cc 60%, #ffffff00);
            position: absolute;
            top: 0;
        }

        .custom-topbar button:hover {
            opacity: 0.8;
        }

        .custom-topbar button:active {
            opacity: 0.9;
        }

        .custom-topbar input {
            display: none;
        }

        .custom-topbar button {
            top: -3px;
            background: none;
            border: none;
            color: white;
            font-size: 16px;
            position: relative;
        }

        .custom-topbar .custom-log-toggle:checked~.custom-log-button {
            filter: sepia(1) saturate(10) brightness(1.5);
        }

        .custom-topbar .custom-skip-toggle:checked~.custom-skip-button {
            filter: sepia(1) saturate(10) brightness(1.5);
        }

        .custom-topbar .custom-skip-toggle:checked~.custom-skip-button img {
            animation: slide 1s linear infinite;
        }

        .custom-topbar .custom-auto-toggle:checked~.custom-auto-button {
            filter: sepia(1) saturate(10) brightness(1.5);  
        }

        .custom-topbar .custom-auto-toggle:checked~.custom-auto-button img {
            animation: revolve 2s linear infinite;
        }


        .custom-topbar img {
            margin: 4px;
            height: 14px;
        }

        .custom-topbar .custom-auto-button {
            display: flex;
            float: right;
            margin-right: 10px;
        }

        .custom-topbar .custom-auto-button:hover .custom-auto-img {
            animation: revolve 2s linear infinite;
        }

        @keyframes revolve {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .custom-topbar .custom-skip-button {
            display: flex;
            float: right;
            margin-right: 10px;
        }

        .custom-topbar .custom-skip-button:hover .custom-skip-img {
            animation: slide 1s linear infinite;
        }

        @keyframes slide {
            0% {
                transform: translate(-5px, 0)
            }

            100% {
                transform: translate(5px, 0)
            }
        }

        .custom-topbar .custom-log-button {
            padding: 0px;
        }

        .custom-topbar .custom-log-button img {
            height: 26px;
        }
`;
const mainHTMLFormat = `
    <div class="custom-container">
        <div class="custom-topbar">
            <input type="checkbox" class="custom-log-toggle"/>
            <button class="custom-log-button">
                <img class="custom-log-img" src="https://files.catbox.moe/6a69x9.png" alt="日志">
            </button>
            <input type="checkbox" class="custom-skip-toggle"/>
            <button class="custom-skip-button">跳过
                <img class="custom-skip-img" src="https://files.catbox.moe/9c7d8s.png" alt="跳过">
            </button>
            <input type="checkbox" class="custom-auto-toggle"/>
            <button class="custom-auto-button">自动
                <img class="custom-auto-img" src="https://files.catbox.moe/1tjxo5.png" alt="自动">
            </button>
        </div>
        <div class="custom-dialogue-box">
            <div class="custom-info">
                <div class="custom-name">{0}</div>
                <img class="custom-print" src="https://files.catbox.moe/du80gs.png" alt="对话"></img>
            </div>
            <div class="custom-divider"></div>
            <div class="custom-text">{1}</div>
            <img class="custom-text-next-img" src="https://files.catbox.moe/ltt6x5.png" alt="下一个"></img>
            <div class="custom-text-action">
                <div class="custom-text-previous"></div>
                <div class="custom-text-next"></div>
            </div>
            <div class="custom-text-indicator"></div>
        </div>
        <img class="custom-scene" src="https://files.catbox.moe/{2}.png" alt="背景"></img>
        <div class="custom-portraits">
{3}
        </div>
    </div>
`;
</script>